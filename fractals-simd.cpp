#include "fractals-simd.h"

namespace fractals::utils {

namespace colormap {

uint32_t gray(unsigned char value)
{
    uint32_t v = value;
    return v << 16 | v << 8 | v;
}

uint32_t red(unsigned char value)
{
    return uint32_t(value) << 16;
}

uint32_t green(unsigned char value)
{
    return uint32_t(value) << 8;
}

uint32_t blue(unsigned char value)
{
    return uint32_t(value);
}

uint32_t yellow(unsigned char value)
{
    return red(value) | green(value);
}

uint32_t cyan(unsigned char value)
{
    return green(value) | blue(value);
}

uint32_t magenta(unsigned char value)
{
    return red(value) | blue(value);
}

uint32_t hot(unsigned char value)
{
    uint32_t red = 255 * std::min(1.f, value / 95.f);
    uint32_t green = value > 96 ? 255 * std::min(1.f, (value - 96) / 95.f) : 0;
    uint32_t blue = value > 192 ? 255 * (value - 192) / 63 : 0;
    return red << 16 | green << 8 | blue;
}

uint32_t jet(unsigned char value)
{
    float red, green, blue;

    // red
    if (value < 96)
        red = 0;
    else if (value < 160)
        red = (value - 96) / 64.f;
    else if (value < 224)
        red = 1;
    else
        red = 1 - (value - 224) / 64;

    // green
    if (value < 32)
        green = 0;
    else if (value < 96)
        green = (value - 32) / 64.f;
    else if (value < 160)
        green = 1;
    else if (value < 224)
        green = 1 - (value - 160) / 64.f;
    else
        green = 0;

    // blue
    if (value < 32)
        blue = 0.5f + value / 64.f;
    else if (value < 96)
        blue = 1;
    else if (value < 160)
        blue = 1 - (value - 96) / 64.f;
    else
        blue = 0;

    return uint32_t(std::round(red * 255)) << 16
         | uint32_t(std::round(green * 255)) << 8
         | uint32_t(std::round(blue * 255));
}

uint32_t cividis(unsigned char value)
{
    uint32_t data[] =
    {
        0x002222, 0x002323, 0x002424, 0x002525, 0x002525, 0x002626, 0x002727, 0x002828, 0x002828, 0x002929, 
        0x002a2a, 0x002a2a, 0x002b2b, 0x002c2c, 0x002c2c, 0x002d2d, 0x002e2e, 0x002e2e, 0x002f2f, 0x003030, 
        0x003030, 0x003131, 0x003131, 0x013232, 0x053333, 0x083333, 0x0c3434, 0x0f3535, 0x123535, 0x143636, 
        0x163737, 0x183737, 0x1a3838, 0x1c3939, 0x1e3a3a, 0x203a3a, 0x213b3b, 0x233c3c, 0x243c3c, 0x263d3d, 
        0x273e3e, 0x293f3f, 0x2a3f3f, 0x2b4040, 0x2d4141, 0x2e4141, 0x2f4242, 0x314343, 0x324343, 0x334444, 
        0x344545, 0x354545, 0x364646, 0x384747, 0x394848, 0x3a4848, 0x3b4949, 0x3c4a4a, 0x3d4a4a, 0x3e4b4b, 
        0x3f4c4c, 0x404c4c, 0x414d4d, 0x424e4e, 0x434e4e, 0x444f4f, 0x455050, 0x465151, 0x475151, 0x485252, 
        0x495353, 0x4a5353, 0x4b5454, 0x4c5555, 0x4d5555, 0x4e5656, 0x4f5757, 0x505757, 0x515858, 0x525959, 
        0x535a5a, 0x545a5a, 0x555b5b, 0x555c5c, 0x565c5c, 0x575d5d, 0x585e5e, 0x595e5e, 0x5a5f5f, 0x5b6060, 
        0x5c6161, 0x5d6161, 0x5e6262, 0x5e6363, 0x5f6363, 0x606464, 0x616565, 0x626565, 0x636666, 0x646767, 
        0x656868, 0x656868, 0x666969, 0x676a6a, 0x686a6a, 0x696b6b, 0x6a6c6c, 0x6b6d6d, 0x6c6d6d, 0x6c6e6e, 
        0x6d6f6f, 0x6e6f6f, 0x6f7070, 0x707171, 0x717272, 0x727272, 0x727373, 0x737474, 0x747474, 0x757575, 
        0x767676, 0x777777, 0x777777, 0x787878, 0x797979, 0x7a7a7a, 0x7b7a7a, 0x7c7b7b, 0x7d7c7c, 0x7e7c7c, 
        0x7e7d7d, 0x7f7e7e, 0x807f7f, 0x817f7f, 0x828080, 0x838181, 0x848282, 0x858282, 0x868383, 0x878484, 
        0x888585, 0x898585, 0x8a8686, 0x8b8787, 0x8c8888, 0x8d8888, 0x8e8989, 0x8f8a8a, 0x908b8b, 0x918b8b, 
        0x928c8c, 0x928d8d, 0x938e8e, 0x948e8e, 0x958f8f, 0x969090, 0x979191, 0x989292, 0x999292, 0x9a9393, 
        0x9b9494, 0x9c9595, 0x9d9595, 0x9e9696, 0x9f9797, 0xa09898, 0xa19999, 0xa29999, 0xa39a9a, 0xa49b9b, 
        0xa59c9c, 0xa69c9c, 0xa79d9d, 0xa89e9e, 0xa99f9f, 0xaaa0a0, 0xaba0a0, 0xaca1a1, 0xada2a2, 0xaea3a3, 
        0xafa4a4, 0xb0a5a5, 0xb1a5a5, 0xb3a6a6, 0xb4a7a7, 0xb5a8a8, 0xb6a9a9, 0xb7a9a9, 0xb8aaaa, 0xb9abab, 
        0xbaacac, 0xbbadad, 0xbcaeae, 0xbdaeae, 0xbeafaf, 0xbfb0b0, 0xc0b1b1, 0xc1b2b2, 0xc2b3b3, 0xc3b3b3, 
        0xc4b4b4, 0xc5b5b5, 0xc6b6b6, 0xc7b7b7, 0xc8b8b8, 0xc9b9b9, 0xcbb9b9, 0xccbaba, 0xcdbbbb, 0xcebcbc, 
        0xcfbdbd, 0xd0bebe, 0xd1bfbf, 0xd2c0c0, 0xd3c0c0, 0xd4c1c1, 0xd5c2c2, 0xd6c3c3, 0xd7c4c4, 0xd9c5c5, 
        0xdac6c6, 0xdbc7c7, 0xdcc8c8, 0xddc8c8, 0xdec9c9, 0xdfcaca, 0xe0cbcb, 0xe1cccc, 0xe2cdcd, 0xe4cece, 
        0xe5cfcf, 0xe6d0d0, 0xe7d1d1, 0xe8d2d2, 0xe9d3d3, 0xead3d3, 0xebd4d4, 0xedd5d5, 0xeed6d6, 0xefd7d7, 
        0xf0d8d8, 0xf1d9d9, 0xf2dada, 0xf3dbdb, 0xf5dcdc, 0xf6dddd, 0xf7dede, 0xf8dfdf, 0xf9e0e0, 0xfbe1e1, 
        0xfce2e2, 0xfde3e3, 0xfee4e4, 0xfee5e5, 0xfee6e6, 0xfee8e8
    };
    return data[value];
}

uint32_t twilight(unsigned char value)
{
    uint32_t data[] =
    {
        0xe2d9d9, 0xe1d9d9, 0xe1d9d9, 0xe0d9d9, 0xe0d9d9, 0xdfd9d9, 0xded9d9, 0xded9d9, 0xddd9d9, 0xdcd9d9, 
        0xdcd9d9, 0xdbd8d8, 0xdad8d8, 0xd9d8d8, 0xd8d8d8, 0xd7d7d7, 0xd6d7d7, 0xd5d6d6, 0xd4d6d6, 0xd3d6d6, 
        0xd2d5d5, 0xd1d5d5, 0xd0d4d4, 0xced3d3, 0xcdd3d3, 0xccd2d2, 0xcbd2d2, 0xc9d1d1, 0xc8d0d0, 0xc7d0d0, 
        0xc5cfcf, 0xc4cece, 0xc2cece, 0xc1cdcd, 0xbfcccc, 0xbecccc, 0xbccbcb, 0xbbcaca, 0xb9c9c9, 0xb8c9c9, 
        0xb6c8c8, 0xb5c7c7, 0xb3c6c6, 0xb2c6c6, 0xb0c5c5, 0xafc4c4, 0xadc3c3, 0xacc2c2, 0xaac2c2, 0xa9c1c1, 
        0xa7c0c0, 0xa6bfbf, 0xa4bebe, 0xa3bebe, 0xa1bdbd, 0xa0bcbc, 0x9ebbbb, 0x9dbaba, 0x9cb9b9, 0x9ab8b8, 
        0x99b8b8, 0x97b7b7, 0x96b6b6, 0x95b5b5, 0x93b4b4, 0x92b3b3, 0x91b2b2, 0x8fb1b1, 0x8eb1b1, 0x8db0b0, 
        0x8cafaf, 0x8aaeae, 0x89adad, 0x88acac, 0x87abab, 0x86aaaa, 0x85a9a9, 0x84a8a8, 0x82a7a7, 0x81a6a6, 
        0x80a5a5, 0x7fa5a5, 0x7ea4a4, 0x7da3a3, 0x7ca2a2, 0x7ba1a1, 0x7aa0a0, 0x799f9f, 0x789e9e, 0x779d9d, 
        0x769c9c, 0x769b9b, 0x759a9a, 0x749999, 0x739898, 0x729797, 0x719696, 0x719595, 0x709494, 0x6f9393, 
        0x6e9292, 0x6e9191, 0x6d9090, 0x6c8f8f, 0x6c8e8e, 0x6b8d8d, 0x6b8c8c, 0x6a8b8b, 0x698a8a, 0x698989, 
        0x688888, 0x688787, 0x678686, 0x678585, 0x668484, 0x668383, 0x668282, 0x658080, 0x657f7f, 0x647e7e, 
        0x647d7d, 0x647c7c, 0x637b7b, 0x637a7a, 0x637979, 0x627878, 0x627777, 0x627676, 0x627575, 0x617373, 
        0x617272, 0x617171, 0x617070, 0x616f6f, 0x606e6e, 0x606d6d, 0x606c6c, 0x606a6a, 0x606969, 0x606868, 
        0x606767, 0x606666, 0x5f6565, 0x5f6464, 0x5f6262, 0x5f6161, 0x5f6060, 0x5f5f5f, 0x5f5e5e, 0x5f5d5d, 
        0x5f5b5b, 0x5f5a5a, 0x5f5959, 0x5f5858, 0x5f5757, 0x5f5555, 0x5e5454, 0x5e5353, 0x5e5252, 0x5e5151, 
        0x5e4f4f, 0x5e4e4e, 0x5e4d4d, 0x5e4c4c, 0x5e4b4b, 0x5e4949, 0x5e4848, 0x5e4747, 0x5e4646, 0x5e4545, 
        0x5e4343, 0x5d4242, 0x5d4141, 0x5d4040, 0x5d3e3e, 0x5d3d3d, 0x5d3c3c, 0x5d3b3b, 0x5d3a3a, 0x5c3838, 
        0x5c3737, 0x5c3636, 0x5c3535, 0x5c3434, 0x5b3232, 0x5b3131, 0x5b3030, 0x5b2f2f, 0x5a2e2e, 0x5a2d2d, 
        0x5a2b2b, 0x592a2a, 0x592929, 0x592828, 0x582727, 0x582626, 0x572525, 0x572424, 0x572323, 0x562222, 
        0x562121, 0x552020, 0x551f1f, 0x541e1e, 0x531e1e, 0x531d1d, 0x521c1c, 0x511b1b, 0x511a1a, 0x501a1a, 
        0x4f1919, 0x4f1919, 0x4e1818, 0x4d1717, 0x4c1717, 0x4c1616, 0x4b1616, 0x4a1515, 0x491515, 0x481515, 
        0x471414, 0x471414, 0x461414, 0x451313, 0x441313, 0x431313, 0x421212, 0x411212, 0x411212, 0x401212, 
        0x3f1212, 0x3e1111, 0x3d1111, 0x3d1111, 0x3c1111, 0x3b1111, 0x3a1111, 0x3a1111, 0x391111, 0x381111, 
        0x371111, 0x371111, 0x361111, 0x361111, 0x351111, 0x341111, 0x341111, 0x331111, 0x331111, 0x321212, 
        0x321212, 0x311212, 0x311313, 0x301313, 0x301414, 0x2f1414
    };
    return data[value];
}

uint32_t turbo(unsigned char value)
{
    uint32_t data[] =
    {
        0x301212, 0x321515, 0x331818, 0x341b1b, 0x351e1e, 0x362121, 0x372424, 0x382727, 0x392a2a, 0x3a2d2d, 
        0x3b2f2f, 0x3c3232, 0x3d3535, 0x3e3838, 0x3f3b3b, 0x3f3e3e, 0x404040, 0x414343, 0x414646, 0x424949, 
        0x424b4b, 0x434e4e, 0x445151, 0x445454, 0x445656, 0x455959, 0x455c5c, 0x455e5e, 0x466161, 0x466464, 
        0x466666, 0x466969, 0x466b6b, 0x476e6e, 0x477171, 0x477373, 0x477676, 0x477878, 0x477b7b, 0x467d7d, 
        0x468080, 0x468282, 0x468585, 0x468787, 0x458a8a, 0x458c8c, 0x448f8f, 0x439191, 0x429494, 0x419696, 
        0x409999, 0x3e9b9b, 0x3d9e9e, 0x3ba0a0, 0x3aa3a3, 0x38a5a5, 0x37a8a8, 0x35abab, 0x33adad, 0x31afaf, 
        0x2fb2b2, 0x2eb4b4, 0x2cb7b7, 0x2ab9b9, 0x28bcbc, 0x27bebe, 0x25c0c0, 0x23c3c3, 0x22c5c5, 0x20c7c7, 
        0x1fc9c9, 0x1ecbcb, 0x1ccdcd, 0x1bd0d0, 0x1ad2d2, 0x1ad4d4, 0x19d5d5, 0x18d7d7, 0x18d9d9, 0x18dbdb, 
        0x18dddd, 0x18dede, 0x18e0e0, 0x19e2e2, 0x19e3e3, 0x1ae4e4, 0x1ce6e6, 0x1de7e7, 0x1fe9e9, 0x20eaea, 
        0x22ebeb, 0x25ecec, 0x27eeee, 0x2aefef, 0x2cf0f0, 0x2ff1f1, 0x32f2f2, 0x35f3f3, 0x38f4f4, 0x3cf5f5, 
        0x3ff6f6, 0x43f7f7, 0x46f8f8, 0x4af8f8, 0x4ef9f9, 0x52fafa, 0x55fafa, 0x59fbfb, 0x5dfcfc, 0x61fcfc, 
        0x65fdfd, 0x69fdfd, 0x6dfefe, 0x71fefe, 0x75fefe, 0x79fefe, 0x7dffff, 0x80ffff, 0x84ffff, 0x88ffff, 
        0x8bffff, 0x8fffff, 0x92ffff, 0x96fefe, 0x99fefe, 0x9cfefe, 0x9ffdfd, 0xa1fdfd, 0xa4fcfc, 0xa7fcfc, 
        0xa9fbfb, 0xacfbfb, 0xaffafa, 0xb1f9f9, 0xb4f8f8, 0xb7f7f7, 0xb9f6f6, 0xbcf5f5, 0xbef4f4, 0xc1f3f3, 
        0xc3f1f1, 0xc6f0f0, 0xc8efef, 0xcbeded, 0xcdecec, 0xd0eaea, 0xd2e9e9, 0xd4e7e7, 0xd7e5e5, 0xd9e4e4, 
        0xdbe2e2, 0xdde0e0, 0xdfdfdf, 0xe1dddd, 0xe3dbdb, 0xe5d9d9, 0xe7d7d7, 0xe9d5d5, 0xebd3d3, 0xecd1d1, 
        0xeecfcf, 0xefcdcd, 0xf1cbcb, 0xf2c9c9, 0xf4c7c7, 0xf5c5c5, 0xf6c3c3, 0xf7c1c1, 0xf8bebe, 0xf9bcbc, 
        0xfababa, 0xfbb8b8, 0xfbb6b6, 0xfcb3b3, 0xfcb1b1, 0xfdaeae, 0xfdacac, 0xfea9a9, 0xfea7a7, 0xfea4a4, 
        0xfea1a1, 0xfe9e9e, 0xfe9b9b, 0xfe9999, 0xfe9696, 0xfe9393, 0xfe9090, 0xfd8d8d, 0xfd8a8a, 0xfc8787, 
        0xfc8484, 0xfb8181, 0xfb7e7e, 0xfa7b7b, 0xf97878, 0xf97575, 0xf87272, 0xf76f6f, 0xf66c6c, 0xf56969, 
        0xf46666, 0xf36363, 0xf26060, 0xf15d5d, 0xf05b5b, 0xef5858, 0xed5555, 0xec5353, 0xeb5050, 0xea4e4e, 
        0xe84b4b, 0xe74949, 0xe54747, 0xe44545, 0xe24343, 0xe14141, 0xdf3f3f, 0xdd3d3d, 0xdc3b3b, 0xda3939, 
        0xd83737, 0xd63535, 0xd43333, 0xd23131, 0xd02f2f, 0xce2d2d, 0xcc2b2b, 0xca2a2a, 0xc82828, 0xc52626, 
        0xc32525, 0xc12323, 0xbe2121, 0xbc2020, 0xb91e1e, 0xb71d1d, 0xb41b1b, 0xb21a1a, 0xaf1818, 0xac1717, 
        0xa91616, 0xa71414, 0xa41313, 0xa11212, 0x9e1010, 0x9b0f0f, 0x980e0e, 0x950d0d, 0x920b0b, 0x8e0a0a, 
        0x8b0909, 0x880808, 0x850707, 0x810606, 0x7e0505, 0x7a0404
    };
    return data[value];
}

}

namespace transforms {

Point<uint32_t> identity(const Buffer& buffer, const Point<uint32_t>& xy)
{
    return xy;
}

Point<uint32_t> horizontal_flip(const Buffer& buffer, const Point<uint32_t>& xy)
{
    return {buffer.width() - xy.x() - 1, xy.y()};
}

Point<uint32_t> vertical_flip(const Buffer& buffer, const Point<uint32_t>& xy)
{
    return {xy.x(), buffer.height() - xy.y() - 1};
}

}

void save_buffer_as_bmp(const Buffer& buffer, const std::string& filename, const Colormap& colormap, const Transform& transform)
{
    std::ofstream file(filename, std::ios::binary);

    uint32_t filesize = (14 + 40) + 4 * buffer.width() * buffer.height();

    uint8_t header[14] = {0};
    header[0] = 'B';
    header[1] = 'M';
    *reinterpret_cast<uint32_t*>(&header[2]) = filesize;
    *reinterpret_cast<uint32_t*>(&header[6]) = 0;
    *reinterpret_cast<uint32_t*>(&header[10]) = 54;

    uint8_t info_header[40] = {0};
    *reinterpret_cast<uint32_t*>(&info_header[0]) = sizeof(info_header);
    *reinterpret_cast<uint32_t*>(&info_header[4]) = buffer.width();
    *reinterpret_cast<uint32_t*>(&info_header[8]) = buffer.height();
    *reinterpret_cast<uint16_t*>(&info_header[12]) = 1;
    *reinterpret_cast<uint16_t*>(&info_header[14]) = 32;

    file.write(reinterpret_cast<char*>(header), sizeof(header));
    file.write(reinterpret_cast<char*>(info_header), sizeof(info_header));

    // Save data
    uint32_t max_value = 0;
    for (uint32_t y = 0; y < buffer.height(); ++y)
    {
        for (uint32_t x = 0; x < buffer.width(); ++x)
        {
            max_value = std::max(max_value, *buffer.ptr(x, y));
        }
    }

    auto zero = char(0);
    for (uint32_t y = 0; y < buffer.height(); ++y)
    {
        for (uint32_t x = 0; x < buffer.width(); ++x)
        {
            auto transformed_xy = transform(buffer, {x, buffer.height() - 1 - y});
            uint32_t value = (max_value > 0 ? colormap(std::round(255.0f * *buffer.ptr(transformed_xy.x(), transformed_xy.y()) / max_value)) : 0);
            file.write(reinterpret_cast<char*>(&value), 4);
        }
    }

    file.close();
}

}
